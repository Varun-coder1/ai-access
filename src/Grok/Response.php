<?php

/**
 * This file is part of the AI Access library.
 * Copyright (c) 2024 David Grudl (https://davidgrudl.com)
 */

declare(strict_types=1);

namespace AIAccess\Grok;

use AIAccess;


/**
 * Represents a response from the Grok (xAI) API.
 */
final class Response implements AIAccess\Response
{
	private ?string $text = null;
	private ?string $finishReason = null;

	/** @var array<string, int|null>|null */
	private ?array $usage = null;


	/**
	 * @param mixed $rawResponse Parsed JSON response data from the API.
	 */
	public function __construct(
		private array $rawResponse,
	) {
		$this->parseRawResponse($this->rawResponse);
	}


	/**
	 * Gets the aggregated text output generated by the model. Can be null if model refused.
	 */
	public function getText(): ?string
	{
		return $this->text;
	}


	/**
	 * Gets the reason the model stopped generating output.
	 * Possible values: 'stop', 'length', 'tool_calls', 'content_filter', etc.
	 */
	public function getFinishReason(): ?string
	{
		return $this->finishReason;
	}


	/**
	 * Gets token usage information.
	 * Keys: 'inputTokens', 'outputTokens', 'totalTokens', 'reasoningTokens'.
	 */
	public function getUsage(): ?array
	{
		return $this->usage;
	}


	/**
	 * Gets the raw, unprocessed response data from the API provider.
	 */
	public function getRawResponse(): mixed
	{
		return $this->rawResponse;
	}


	/**
	 * Parses the raw Grok API response.
	 */
	private function parseRawResponse(array $data): void
	{
		if (!is_array($data)) {
			return; // Allow null/empty response, client should check
		}

		// Extract text content from the first choice's message
		// Content can be null if model refused or in other cases.
		$this->text = $data['choices'][0]['message']['content'] ?? null;

		// Check for refusal reason if content is null
		if ($this->text === null && isset($data['choices'][0]['message']['refusal'])) {
			trigger_error('Grok model refused to generate content: ' . $data['choices'][0]['message']['refusal'], E_USER_WARNING);
		}

		// Extract finish reason from the first choice
		$this->finishReason = $data['choices'][0]['finish_reason'] ?? null;

		// Extract usage statistics
		if (isset($data['usage'])) {
			$this->usage = [
				'inputTokens' => $data['usage']['prompt_tokens'] ?? 0,
				'outputTokens' => $data['usage']['completion_tokens'] ?? 0,
				'totalTokens' => $data['usage']['total_tokens'] ?? 0,
				'reasoningTokens' => $data['usage']['completion_tokens_details']['reasoning_tokens'] ?? null,
				// Add prompt details if available
				'promptTextTokens' => $data['usage']['prompt_tokens_details']['text_tokens'] ?? null,
				'promptImageTokens' => $data['usage']['prompt_tokens_details']['image_tokens'] ?? null,
				'promptAudioTokens' => $data['usage']['prompt_tokens_details']['audio_tokens'] ?? null,
				'promptCachedTokens' => $data['usage']['prompt_tokens_details']['cached_tokens'] ?? null,
				// Add completion details if available
				'completionAudioTokens' => $data['usage']['completion_tokens_details']['audio_tokens'] ?? null,
				'completionAcceptedPredictionTokens' => $data['usage']['completion_tokens_details']['accepted_prediction_tokens'] ?? null,
				'completionRejectedPredictionTokens' => $data['usage']['completion_tokens_details']['rejected_prediction_tokens'] ?? null,
			];

			// Clean up null values from usage array for clarity
			$this->usage = array_filter($this->usage, fn($value) => $value !== null);

		} else {
			$this->usage = null;
		}
	}
}
