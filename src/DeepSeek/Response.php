<?php

/**
 * This file is part of the AI Access library.
 * Copyright (c) 2024 David Grudl (https://davidgrudl.com)
 */

declare(strict_types=1);

namespace AIAccess\DeepSeek;

use AIAccess;


/**
 * Represents a response from the DeepSeek API.
 */
final class Response implements AIAccess\Response
{
	private ?string $text = null; // Can be null according to schema
	private ?string $finishReason = null;

	/** @var array<string, int>|null */
	private ?array $usage = null;


	/**
	 * @param mixed $rawResponse Parsed JSON response data from the API.
	 */
	public function __construct(
		private array $rawResponse,
	) {
		$this->parseRawResponse($this->rawResponse);
	}


	/**
	 * Gets the aggregated text output generated by the model. Can be null.
	 */
	public function getText(): ?string
	{
		return $this->text;
	}


	/**
	 * Gets the reason the model stopped generating output.
	 * Possible values: 'stop', 'length', 'content_filter', 'tool_calls', 'insufficient_system_resource'.
	 */
	public function getFinishReason(): ?string
	{
		return $this->finishReason;
	}


	/**
	 * Gets token usage information.
	 * Keys: 'inputTokens', 'outputTokens', 'totalTokens', 'reasoningTokens'.
	 */
	public function getUsage(): ?array
	{
		return $this->usage;
	}


	/**
	 * Gets the raw, unprocessed response data from the API provider.
	 */
	public function getRawResponse(): mixed
	{
		return $this->rawResponse;
	}


	/**
	 * Parses the raw DeepSeek API response.
	 */
	private function parseRawResponse(array $data): void
	{
		if (!is_array($data)) {
			// Allow null response for certain scenarios? Or throw?
			// Let's be lenient for now, caller should check response.
			return;
			// throw new AIAccess\ApiException('Invalid response data');
		}

		// Extract text content from the first choice's message
		if (isset($data['choices'][0]['message']['content'])) {
			// Content can be null according to the schema
			$this->text = $data['choices'][0]['message']['content'];
		} else {
			$this->text = null;
		}

		// Extract finish reason from the first choice
		if (isset($data['choices'][0]['finish_reason'])) {
			$this->finishReason = $data['choices'][0]['finish_reason'];
		}

		// Extract usage statistics
		if (isset($data['usage'])) {
			$this->usage = [
				'inputTokens' => $data['usage']['prompt_tokens'] ?? 0,
				'outputTokens' => $data['usage']['completion_tokens'] ?? 0,
				'totalTokens' => $data['usage']['total_tokens'] ?? 0,
				// Reasoning tokens might be nested or directly under usage
				'reasoningTokens' => $data['usage']['completion_tokens_details']['reasoning_tokens']
					?? $data['usage']['reasoning_tokens']
					?? null, // Be flexible here
			];
			// Remove null reasoningTokens if not present
			if ($this->usage['reasoningTokens'] === null) {
				unset($this->usage['reasoningTokens']);
			}

			// Add cache hit/miss tokens if present
			if (isset($data['usage']['prompt_cache_hit_tokens'])) {
				$this->usage['promptCacheHitTokens'] = $data['usage']['prompt_cache_hit_tokens'];
			}
			if (isset($data['usage']['prompt_cache_miss_tokens'])) {
				$this->usage['promptCacheMissTokens'] = $data['usage']['prompt_cache_miss_tokens'];
			}
		} else {
			$this->usage = null;
		}
	}
}
