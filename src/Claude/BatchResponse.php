<?php

/**
 * This file is part of the AI Access library.
 * Copyright (c) 2024 David Grudl (https://davidgrudl.com)
 */

declare(strict_types=1);

namespace AIAccess\Claude;

use AIAccess;
use AIAccess\BatchStatus;
use AIAccess\Message;


/**
 * Represents the state and eventual result of a Claude Batch API job.
 */
final class BatchResponse implements AIAccess\BatchResponse
{
	/** @var Message[]|null */
	private ?array $outputMessagesCache = null;
	private bool $outputRetrievalAttempted = false;


	public function __construct(
		private Client $client,
		private array $batchData,
	) {
	}


	public function getStatus(): BatchStatus
	{
		return match ($this->batchData['processing_status'] ?? null) {
			'in_progress' => BatchStatus::InProgress,
			'ended' => BatchStatus::Completed,
			'canceling' => BatchStatus::Failed,
			default => BatchStatus::Other,
		};
	}


	/**
	 * Gets the output messages generated by the completed batch job.
	 * Keys in the returned array correspond to custom_id values from requests.
	 * @return Message[]|null
	 */
	public function getOutputMessages(): ?array
	{
		if ($this->outputMessagesCache !== null
			|| $this->outputRetrievalAttempted
			|| $this->getStatus() !== BatchStatus::Completed
			|| empty($this->batchData['results_url'])
		) {
			return $this->outputMessagesCache;
		}

		try {
			$content = $this->client->sendRequest($this->batchData['results_url'], [], 'GET', parseJson: false);
			return $this->outputMessagesCache = $this->parseRawResponse($content);

		} catch (AIAccess\Exception | \JsonException $e) {
			$this->outputRetrievalAttempted = true;
			trigger_error('Failed to retrieve or parse batch output: ' . $e->getMessage(), E_USER_WARNING);
			return null;
		}
	}


	private function parseRawResponse(mixed $jsonl): ?array
	{
		$outputMessages = [];
		$lines = explode("\n", trim($jsonl));

		foreach ($lines as $line) {
			if (empty(trim($line))) {
				continue;
			}

			$lineData = json_decode($line, true, 512, JSON_THROW_ON_ERROR);
			$customId = $lineData['custom_id'] ?? null;

			if ($customId === null) {
				continue;
			}

			$resultType = $lineData['result']['type'] ?? null;
			if ($resultType === 'succeeded') {
				if (isset($lineData['result']['message']['content'])) {
					$content = '';
					foreach ($lineData['result']['message']['content'] as $contentBlock) {
						if ($contentBlock['type'] === 'text') {
							$content .= $contentBlock['text'];
						}
					}

					$outputMessages[$customId] = new Message(trim($content), AIAccess\Role::Model);
				}
			} elseif ($resultType === 'errored') {
				$errorMsg = "Error in request '{$customId}'";
				if (isset($lineData['result']['error'])) {
					$error = $lineData['result']['error'];
					$errorMsg .= ': ' . ($error['message'] ?? 'Unknown error');
					if (isset($error['type'])) {
						$errorMsg .= " (type: {$error['type']})";
					}
				}
				trigger_error($errorMsg, E_USER_WARNING);
			}
		}

		return $outputMessages;
	}


	public function getError(): ?string
	{
		if (isset($this->batchData['request_counts'])) {
			$counts = $this->batchData['request_counts'];
			$errorInfo = [];

			if (isset($counts['errored']) && $counts['errored'] > 0) {
				$errorInfo[] = "{$counts['errored']} requests encountered errors";
			}

			if (isset($counts['expired']) && $counts['expired'] > 0) {
				$errorInfo[] = "{$counts['expired']} requests expired";
			}

			if (isset($counts['canceled']) && $counts['canceled'] > 0) {
				$errorInfo[] = "{$counts['canceled']} requests were canceled";
			}

			if (!empty($errorInfo)) {
				return 'Batch encountered issues: ' . implode(', ', $errorInfo);
			}
		}

		return null;
	}


	public function getCreatedAt(): ?\DateTimeImmutable
	{
		if (isset($this->batchData['created_at'])) {
			try {
				return new \DateTimeImmutable($this->batchData['created_at']);
			} catch (\Throwable) {
			}
		}
		return null;
	}


	public function getCompletedAt(): ?\DateTimeImmutable
	{
		if (isset($this->batchData['ended_at'])) {
			try {
				return new \DateTimeImmutable($this->batchData['ended_at']);
			} catch (\Throwable) {
			}
		}
		return null;
	}


	public function getRawResult(): mixed
	{
		return $this->batchData;
	}


	/**
	 * Gets the unique identifier of the batch job.
	 */
	public function getId(): string
	{
		return $this->batchData['id'];
	}
}
